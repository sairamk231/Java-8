1. What is a Stream?
A Stream represents a sequence of elements from a data source (Collection, Array, I/O) that supports functional-style operations.

Interview one-liner
‚ÄúA stream processes data from a source using a pipeline of functional operations.‚Äù

2. What Stream is NOT (Very Important)

‚ùå Not a data structure
‚ùå Does not store data
‚ùå Does not modify the source
‚ùå Cannot be reused

‚úî It processes data
‚úî One-time use only

3. Why Streams Were Introduced (Java 8)?
Problems Before Java 8:
Verbose loops
External iteration
Hard to parallelize
Boilerplate code

Benefits of Streams:

‚úî Declarative style
‚úî Less boilerplate
‚úî Lazy evaluation
‚úî Easy parallelism
‚úî Better readability

4. Stream Pipeline (üî• MUST KNOW)
Source ‚Üí Intermediate Operations ‚Üí Terminal Operation

Intermediate Operations:
Intermediate operations in Java Streams return another Stream. They are typically used to transform or filter the elements of the original Stream. Since they are lazy, meaning they do not perform any processing until a terminal operation is called, multiple intermediate operations can be chained together.

Common Intermediate Operations:
map(Function<T, R>): Transforms each element of the Stream into another form using the provided function.
filter(Predicate<T>): Selects elements from the Stream based on a specified condition.
flatMap(Function<T, Stream<R>>): Transforms each element into zero or more elements by applying a function that returns a stream for each element.
distinct(): Removes duplicate elements from the Stream.
sorted(): Sorts the elements of the Stream.
limit(long n): Truncates the Stream to be no longer than the specified size.
skip(long n): Skips the first n elements of the Stream.
peek(Consumer<T>): Performs a specified action on each element of the Stream without consuming the elements.

2. Terminal Operations:
Terminal operations are those operations that consume the Stream and produce a result, such as a value, a collection, or even a side effect.
Once a terminal operation is invoked, the Stream is processed and cannot be reused.

Common Terminal Operations:
forEach(Consumer<T>): Acts as each element of the Stream.
collect(Collector<T, A, R>): Reduces the elements of the Stream into a mutable result container, such as a list or a map.
reduce(BinaryOperator<T>): Reduces the elements of the Stream to a single value using an associative accumulation function.
count(): Returns the count of elements in the Stream.
anyMatch(Predicate<T>): Returns true if any element of the Stream matches the given predicate.
allMatch(Predicate<T>): Returns true if all elements of the Stream match the given predicate.
noneMatch(Predicate<T>): Returns true if no elements of the Stream match the given predicate.
findFirst(): Returns an Optional describing the first element of the Stream, or an empty Optional if the Stream is empty.
findAny(): Returns an Optional describing some element of the Stream, or an empty Optional if the Stream is empty.

3. Short-Circuit Operations
Short-circuit operations are a subset of terminal operations that do not need to process the entire Stream to produce a result. 
They can provide an early exit from the stream processing pipeline, potentially saving computation time.

Common Short-Circuit Operations:

anyMatch(Predicate<T>): Stops processing and returns true if any element matches the given predicate.
allMatch(Predicate<T>): Stops processing and returns false if any element does not match the given predicate.
noneMatch(Predicate<T>): Stops processing and returns true if no elements match the given predicate.
findFirst(): Returns the first element encountered in the Stream and then stops processing.
findAny(): Returns any element encountered in the Stream and then stops processing.

Eg:    list.stream()
        .filter(x -> x > 10)
        .map(x -> x * 2)
        .forEach(System.out::println);

5. Stream Sources (All Ways)
5.1 From Collection
List<Integer> list = List.of(1, 2, 3);
Stream<Integer> s = list.stream();

5.2 From Array
int[] arr = {1, 2, 3};
IntStream s = Arrays.stream(arr);

5.3 Using Stream.of()
Stream<String> s = Stream.of("Java", "Spring");

5.4 Infinite Streams
Stream<Integer> s = Stream.iterate(1, n -> n + 1);

6. Types of Streams
6.1 Sequential Stream (Default)
list.stream();

6.2 Parallel Stream
list.parallelStream();


‚úî Uses ForkJoinPool
‚ùå Order not guaranteed

7. Intermediate Operations (Lazy)
Executed only when terminal operation is called

7.1 filter()
List<Integer> list = List.of(1, 2, 3, 4);

list.stream()
    .filter(x -> x % 2 == 0)
    .forEach(System.out::println);

Output

2
4

7.2 map()
list.stream()
    .map(x -> x * x)
    .forEach(System.out::println);

Output
1
4
9
16

7.3 flatMap() (üî• Interview Favorite)
List<List<Integer>> list =
    List.of(List.of(1, 2), List.of(3, 4));

list.stream()
    .flatMap(l -> l.stream())
    .forEach(System.out::println);

Output

1
2
3
4

9. map() vs flatMap() ‚Äì Side-by-Side Comparison
| Aspect         | `map()`         | `flatMap()`           |
| -------------- | --------------- | --------------------- |
| Transformation | One-to-one      | One-to-many           |
| Return type    | `R`             | `Stream<R>`           |
| Result stream  | Nested possible | Always flattened      |
| Common use     | Field mapping   | Nested collections    |
| Output size    | Same as input   | Can increase/decrease |


7.4 distinct()
List<Integer> list = List.of(1, 2, 2, 3);
list.stream()
    .distinct()
    .forEach(System.out::println);

Output

1
2
3

7.5 sorted()
List<Integer> list = List.of(3, 1, 2);

list.stream()
    .sorted()
    .forEach(System.out::println);


Output

1
2
3

Custom Sort

list.stream()
    .sorted((a, b) -> b - a)
    .forEach(System.out::println);

Output
3
2
1

7.6 limit() & skip()
Stream.iterate(1, n -> n + 1)
      .skip(2)
      .limit(3)
      .forEach(System.out::println);

Output
3
4
5

8. Terminal Operations (üî• MUST KNOW)
8.1 forEach()
list.stream().forEach(System.out::println);

8.2 collect()
List<Integer> even =
    list.stream()
        .filter(x -> x % 2 == 0)
        .collect(Collectors.toList());

System.out.println(even);

Output
[2, 4]

8.3 reduce() (üî• Very Important)
List<Integer> list = List.of(1, 2, 3, 4);

int sum = list.stream()
              .reduce(0, (a, b) -> a + b);

System.out.println(sum);

Output
10

8.4 count()
long count = list.stream().count();
System.out.println(count);

Output
4

8.5 min() & max()
int max = list.stream()
              .max(Integer::compare)
              .get();

System.out.println(max);

Output
4

8.6 anyMatch(), allMatch(), noneMatch()
System.out.println(list.stream().anyMatch(x -> x > 3));
System.out.println(list.stream().allMatch(x -> x > 0));
System.out.println(list.stream().noneMatch(x -> x < 0));

Output
true
true
true

8.7 findFirst() & findAny()
System.out.println(list.stream().findFirst().get());

Output
1

9. Streams with Custom Objects (üî• MUST KNOW)
class Employee {
    int id;
    String name;
    int salary;

    Employee(int id, String name, int salary) {
        this.id = id;
        this.name = name;
        this.salary = salary;
    }
}

List<Employee> list = List.of(
    new Employee(1, "Sai", 50000),
    new Employee(2, "Ram", 70000)
);

list.stream()
    .filter(e -> e.salary > 60000)
    .map(e -> e.name)
    .forEach(System.out::println);


Output
Ram

10. Collectors API (üî• VERY IMPORTANT)
10.1 groupingBy()
Map<Integer, List<Employee>> map =
    list.stream()
        .collect(Collectors.groupingBy(e -> e.salary));

System.out.println(map.size());

10.2 partitioningBy()
Map<Boolean, List<Employee>> map =
    list.stream()
        .collect(Collectors.partitioningBy(e -> e.salary > 60000));

System.out.println(map.get(true).size());

10.3 joining()
List<String> names = List.of("Java", "Spring");

String result =
    names.stream()
         .collect(Collectors.joining(", "));

System.out.println(result);

Output
Java, Spring

11. Primitive Streams (Performance üî•)
Stream Type	Primitive
IntStream	int
LongStream	long
DoubleStream	double
IntStream.range(1, 5)
         .forEach(System.out::println);

Output
1
2
3
4

‚úî Avoids autoboxing
‚úî Faster performance

12. Parallel Streams (üî• Tricky)
list.parallelStream()
    .forEach(System.out::println);

Key Points:
Order not guaranteed
Not suitable for:
Small datasets
Blocking I/O
Stateful lambdas

13. Lazy Evaluation (üî• Important)
list.stream()
    .filter(x -> {
        System.out.println("filter " + x);
        return x > 2;
    })
    .findFirst();


‚úî Stops processing once condition satisfied
